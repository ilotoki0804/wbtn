# WBTN 오픈 데이터 포맷

## 구조

WBTN 포맷은 sqlite 데이터베이스로 이루어져 있으며, sqlite3를 통해 접근할 수 있습니다.

### 필요한 PRAGMA 선언값

#### `application_id`

WBTN 포맷의 sqlite상 `application_id`는 `0x5742544e`(혹은 십진수로는 `1463964750`)로 설정되어 있어야 합니다. (`PRAGMA application_id=0x5742544e`)

#### `user_version`

WBTN 포맷의 sqlite상 `user_version`은 스키마 버전을 의미하며, `1000`부터 시작해 스키마 버전이 올라가면 수가 증가하고 호환되지 않는 스키마 변화가 있을 때 1000으로 정수 나눗셈을 한 뒤 1을 더하고 다시 1000을 곱한 값을 설정하는 방식으로 작동합니다.
이때 스키마 버전은 wbtn 패키지상의 버전을 말하는 것이 아닌, WBTN 포맷이 사용하는 sqlite 데이터베이스의 구조를 의미하는 것입니다. 즉, wbtn 패키지에서 어떠한 변화가 있고 버전이 변경되더라도, 데이터베이스 구조가 변경되지 않는다면 스키마 버전은 업데이트되지 않습니다.
파일에 설정된 `user_version`을 1000으로 나눈 값이 현재 버전을 1000으로 나눈 값과 상이할 경우 스키마 버전이 호환되지 않는 것으로 간주됩니다.
스키마 버전이 호환되지 않는 경우 자동으로 예외가 발생하나 필요하다면 `WBTN_FORCE_OPEN_PAST_FORMAT`(호환되지 않는 과거 버전을 열 경우)이나 `WBTN_FORCE_OPEN_FUTURE_FORMAT`(호환되지 않는 미래 버전을 열 경우)을 `0`이 아닌 값으로 설정해 열도록 설정할 수 있습니다.
이 설정을 통해 데이터베이스를 접근했을 때 데이터베이스와 그 안의 데이터와 그걸 해석하는 패키지가 어떤 영향을 줄지는 모릅니다. 하지만 스키마 버전을 호환되지 않는다고 직접 밝힌 이상, 가능하다면 호환이 되는 버전의 패키지로 업데이트해 사용하는 것을 권장합니다.
다만, 호환되지 않는 과거 버전을 열 때 오류를 내는 대신 더 최신 버전은 자동으로 스키마를 업그레이드할 수도 있습니다. 이 경우에는 `WBTN_FORCE_OPEN_PAST_FORMAT` 플래그와는 무관하게 작동합니다. 별도의 플래그를 통해야지만 업그레이드되도록 할 수도 있고, 반대로 플래그를 설정하지 않으면 자동으로 스키마가 업그레이드되도록 할 수도 있고, 그냥 스키마 업그레이드를 포기하고 항상 오류를 낼 수도 있습니다(이 경우에는 `WBTN_FORCE_OPEN_PAST_FORMAT`가 사용될 수도 있습니다). 아직까진 스키마 버전이 `1000` 하나뿐임으로 확실한 건 없습니다.

`user_version`은 후술할 `info` 테이블의 `sys_agent_version`과는 다릅니다. `sys_agent_version`은 에이전트, 즉 `wbtn` 패키지의 버전을 의미하고, `user_version`은 `.wbtn` 파일 자체의 스키마 버전을 의미합니다. 즉, `wbtn` 패키지의 버그 수정, 일부 기능 개선, 심지어는 특별한 데이터 추가 등의 일이 일어나더라도,
`.wbtn` 파일의 스키마가 변경되지 않는다면 `user_version`은 변경되지 않습니다.

### `conversion`

json_encoded가 1일 경우 JSON 인코딩된 값이 들어갑니다. 이 경우 wbtn 패키지에서는 자동으로 값을 넣을 때는 json으로 인코딩하고 사용할 때는 디코딩합니다.
json_encoded가 1일 경우 반드시 그 데이터는 sqlite의 `json()` 함수에 통과시켰을 때 오류 없이 파싱되어야 합니다. 따라서 이론적으론 json5 포맷이나 jsonb 데이터 또한 포함될 수 있습니다.
wbtn의 다양한 함수들에서 `to_json` 파라미터를 `True`로 설정할 경우 json 값이 데이터에 들어갑니다. 만약 해당 파라미터를 `"jsonb"`로 설정했다면, sqlite의 `jsonb()` 함수로 인코딩된 값이 들어갑니다. 두 경우 모두 `json()` 함수를 
`json()` 함수는 sqlite 버전 3.38.0 (2022-02-22)부터 sqlite에 기본으로 탑재되기 시작하였음으로 그 전의 sqlite 버전을 탑재한 파이썬 3.10.2 미만의 버전에서는 사용이 어렵습니다. 다만, 이 함수가 없더라도 `.wbtn` 포맷에서 해당 함수를 이용하는 기능은 아직까지는 없기 때문에 
`jsonb()` 함수는 sqlite 버전 3.45.0 (2024-01-15)부터 추가되었음으로, 파이썬 3.8 이상의 **최신 마이크로릴리즈**에서 사용할 수 있습니다.
좀 더 정확히는 파이썬 3.10.13 이상, 3.11.8 이상, 3.12.1 이상, 3.13.0 이상에서 사용 가능합니다.
상당히 최근에 나온 기능인 만큼 만약 최고의 호환성을 원하는 경우 `jsonb()`의 사용을 피하세요.
일반적인 원시 값 (문자열, 정수, 부동수, None, bytes 등)을 사용한다면 `to_json`를 `False`로 두는 것이 좋습니다. 만약 리스트, 오브젝트 등의 JSON 기능이 필요하다면 `to_json`을 `True`로 두어야 합니다.
`"jsonb"`를 사용하는 것은 신중해야 합니다. sqlite의 jsonb는 sqlite 쿼리 내에서 json 관련 계산 시에 성능을 높이기 위해 만들어졌습니다. 저장 용량을 줄이는 효과도 있으나 미미하고, jsonb 값을 sqlite 밖으로 불러올 때는 반대로 오버해드가 발생할 수 있습니다. 띠라서 일반적인 상황에선 jsonb를 사용하는 것을 권장하지 않고, 하위 호환성의 문제에서 비교적 자유롭고 SQL 쿼리를 통해 데이터를 조작할 확률이 상당히 높은 경우에만 사용해 주세요.
`json`값을 사용할 때에 이미 json으로 인코딩하지 않도록 주의해 주세요. 만약 이미 인코딩된 데이터를 저장하고 싶다면 `json_raw`와 `jsonb_raw`를 사용할 수 있습니다. 이 경우, 값은 str로 받고 `json.dumps()` 없이 값을 바로 저장하거나 jsonb 형식으로 저장합니다. 이때 `jsonb_raw`가 jsonb bytes를 값으로 받는 것이 아니라 일반적인 문자열로 된 json값을 받는 것에 유의하세요. `jsonb_raw`는 jsonb로 저장한다는 의미해서 jsonb를 사용하는 것이지 jsonb blob를 값으로 받는다는 의미가 아닙니다.
또한 `json_raw`를 사용한다고 하더라도 값을 불러올 때는 파싱을 해서 내보내집니다.

사용 환경에서의 sqlite 버전을 알기 위해선 다음의 명령어를 사용하세요.

```console
py -c "from sqlite3 import sqlite_version; print(sqlite_version)"
```
